# Example Runs — Golden Scenarios (Architecture/System Design Only)

These are **behavioral** golden cases for V0: they define expected *properties* and system decisions, not exact prose.

Use these as:
- acceptance tests
- regression anchors when prompts/models change
- debugging reference

All cases are intentionally framed as **system design / architecture** prompts suitable for sharing with contractors.

---

## Case 1 — API design with constraints (no revision expected)

**SolveRequest**
```json
{
  "prompt": "Design a minimal REST API for a 'RunRecord logging service' that accepts run events and supports querying by run_id. Include endpoints and example request/response shapes.",
  "output_format": "markdown",
  "constraints": ["Include exactly 4 endpoints", "Keep the design MVP-friendly (no auth details)."]
}
```

**Expected properties**
- Critique runs and reports **no blocker/major** issues.
- No revision loop.
- Output respects the “exactly 4 endpoints” constraint (best effort).
- `assumptions[]` and `known_issues[]` present.
- RunRecord includes plan, candidate v1, critique v1, final response.

---

## Case 2 — Conflicting architectural constraints (must surface known issue)

**SolveRequest**
```json
{
  "prompt": "Propose an architecture for an event processing pipeline that guarantees exactly-once delivery with zero operational complexity.",
  "output_format": "markdown",
  "constraints": ["No external dependencies", "Exactly-once delivery required"]
}
```

**Expected properties**
- System proceeds best-effort (does not block).
- Critique flags a **major** conflict / infeasibility claim (e.g., exactly-once vs no dependencies vs zero ops).
- Optional revision (≤1) attempts to propose a pragmatic design and document trade-offs.
- `known_issues` explicitly notes which constraints conflict and what assumption/trade-off was chosen.

---

## Case 3 — Structured output required (architecture as JSON)

**SolveRequest**
```json
{
  "prompt": "Return a JSON architecture description for a service that runs 'Normalize → Generate → Critique → Log' on user requests.",
  "output_format": "JSON",
  "constraints": ["Return valid JSON with keys: components, data_flows, persistence, failure_modes"]
}
```

**Expected properties**
- Generator attempts structured output.
- If parse fails, exactly **one** repair attempt occurs.
- If still failing, response may fall back to text but logs parse failure; `known_issues` mentions JSON validity issue.
- Critique flags schema/format violations as **major**.
- ≤1 revision.

---

## Case 4 — Under-specified requirements (best-effort normalize + explicit assumptions)

**SolveRequest**
```json
{
  "prompt": "Design a 'policy gate' component for controlling tool access in an AI system. Provide responsibilities and interfaces."
}
```

**Expected properties**
- Normalizer infers default output format (markdown/plain text).
- Critique flags missing inputs (e.g., policy categories, decision criteria, audit requirements).
- `assumptions` lists reasonable defaults (e.g., allow/deny lists, audit log fields).
- No blocking; best-effort design returned.

---

## Case 5 — Multi-view coverage requirement (end-to-end system design)

**SolveRequest**
```json
{
  "prompt": "Design a governed, self-improving operations assistant that produces plans and documents, and continuously improves using run records and evaluations. Provide an end-to-end architecture and key data contracts.",
  "output_format": "markdown"
}
```

**Expected properties**
- Critique includes multi-view coverage (at minimum): requirements/scope, architecture, risk, compliance (high-level), security/ops, evaluation/experimentation.
- If major coverage gaps are identified, ≤1 revision attempts to add missing sections.
- `known_issues` includes open questions / missing inputs that materially affect the design.

---

## Case 6 — Failure mode emphasis (graceful degradation)

**SolveRequest**
```json
{
  "prompt": "Design a run controller for an LLM pipeline that must handle timeouts, partial failures, and structured-output parse errors. Include a failure-mode table.",
  "output_format": "markdown",
  "constraints": ["Include a table with at least 6 failure modes."]
}
```

**Simulated condition**
- LLM provider times out during critique (or produces malformed JSON).

**Expected properties**
- System returns best-effort output based on available artifacts.
- `known_issues` mentions degraded mode due to timeout/parse failure.
- RunRecord includes which step failed + error details.
- Constraints are preserved and not silently dropped.

---

## Case 7 — Deterministic contract enforcement (constraints must be checked)

**SolveRequest**
```json
{
  "prompt": "Propose a deterministic constraint checker layer for verifying output contracts in an AI system. Include what can be checked deterministically vs heuristically.",
  "output_format": "markdown",
  "constraints": ["Must include a section titled 'Deterministic Checks'", "Must include a section titled 'Heuristic Checks'"]
}
```

**Expected properties**
- Constraints appear in NormalizedProblem.
- Critique checks for section-title requirements explicitly.
- Violations trigger **major** and optional revision (≤1).
