# Design Brief: Generalized Multi-Agent Problem-Solving System

## Objective

You are a world-class engineer and systems designer tasked with designing a **generalized, production-grade multi-agent system** capable of producing **optimal solutions** to *arbitrary problem statements* with high reliability and repeatability.

The system must accept a structured set of inputs defining a problem, its objectives, constraints, and context, and must produce one or more outputs that constitute an **optimal solution** under those definitions.

The primary goal is not to optimize for a specific domain, but to design a system that **consistently produces high-quality solutions across domains**, while remaining auditable, extensible, and resistant to regression.

You should design this system **from first principles** without assuming any constraints. Thinking and designing from first principles will allow you to logically support, defend, and articulate how the system you have designed is optimal. You have full permission to change, add, or remove components freely in pursuit of the most optimal design.

------

## Design Mandate

You must design:

- A) The inputs: a set of artifacts that are uploaded to the system by the user.
- B) The outputs: a set of artifacts that are produced by the system. The outputs will be defined by the user in the Output Specification artifact, which will be provided by the user as part of the inputs.
- C) The system: a software system leveraging agents that takes in inputs and produces outputs

You must ensure:

- That each of the components of the system – inputs, outputs, system – are optimally designed at the component level.
- That the overall system – composed of inputs, outputs, system – is optimally designed at the architectural and system level. 

The system must:

- Reliably generate solutions that are optimal per stated objectives under explicit constraints
- Scale from simple tasks to complex, multi-artifact problem statements
- Support iterative improvement while preventing regressions
- Be suitable for long-lived, continuously improving systems

As part of the design, explicitly identify which elements of the system should be **immutable** (i.e., invariant across runs and problems) versus **mutable** (i.e., configurable, replaceable, or evolving).

------

## A) Design the inputs

The following are suggested inputs proposed as a starting point - some are required, others are optional as noted below. You should add, remove, refine, rename, or restructure them as needed. Your first job is define what these should be. In aggregate, the inputs represent the design brief, which needs to be optimized in support of the system's objectives and considerations outlined above.  

1. **Problem Statement / Design Brief (required)**
   A clear articulation of the problem to be solved, including scope and success criteria.

2. **Framework: Objectives, Constraints, Principles**

   - Objectives: what the solution means (optional)
   - Constraints: hard and soft limits the solution must respect (optional)
   - Principles: value statements or priorities used to further guide the design (optional)

3. **Output Specification (required)**
   A description of the required outputs and artifacts produced by the system.
   This should remain intentionally open-ended and non-prescriptive as it will be defined differently by the user of the system depending on the problem being tackled.

4. **Human Suggestions (optional)**
   Human-provided guidance, ideas, or candidate approaches.
   These may be designated as:

   - Mandatory (must be implemented unless impossible or unsafe)
   - Optional (inputs to consider but not required)

5. **Additional Context (optional)**
   Any relevant background information, assumptions, or environmental details.

6. **Prior Solutions (optional)**
   Outputs produced by previous runs of the same system, including:

   - Artifacts
   - Metadata
   - Logs or evaluations

   The system must ensure that any newly proposed solution is **at least as optimal as prior solutions**, or explicitly justify regressions. However, when a prior solution is provided, the system's goal is to provide a more optimal solution that respects constraints provided.
   
   The system should always consider all the inputs provided. The system should never ignore or disregard inputs provided. 

------

## B) Design the outputs (to be re-designed as needed)

The system should produce, at minimum:

1. **Primary Outputs (required)**
   All artifacts defined by the Output Specification. Typically, this will constitute the solution design itself and its related elements (e.g., architectural diagrams, documentation, etc.).
2. **Solution Confidence Score (required)**
   An explicit assessment of how well the solution satisfies objectives and constraints.
3. **Tradeoff Analysis (required)**
   A clear explanation of what was sacrificed, deprioritized, or left unresolved, and why.
4. **Reasoning Trace (required)**
   A *compressed* explanation of key decisions and rationale
   (not raw chain-of-thought).
5. **Comparison to Alternative Solutions (optional)**
   An explicit delta highlighting improvements or regressions to other solutions considered, with justification. If prior solutions or suggested solutions were stored from prior runs or candidate solutions were provided as inputs those should be included in this analysis as well. 
6. **Error Log (required)**
   A structured record of failures, ambiguities, unmet checks, or degraded behavior.

------

## C) Design the system (to be re-designed as needed)

Your job is to design a system that is conducive to producing **optimal solutions** to *arbitrary problem statements* with high reliability and repeatability. You are a world-class engineer and systems designer tasked with designing a **generalized, production-grade multi-agent system,** although combining agents with any other technologies or tools as needed.

## Iterative Operation

The system should be designed such that its outputs can be fed back into its inputs, enabling iterative refinement and continuous improvement across runs.
